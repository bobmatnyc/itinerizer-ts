---
timestamp: 2025-12-18T21:31:04.916931+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Implement geocoding service", "timestamp": "2025-12-18T21:31:04.915567+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement a geocoding service to add coordinates to locations during PDF import.

**Use Nominatim (OpenStreetMap)** - Free, no API key required, 1 request/second rate limit.

## Create `src/services/geocoding.service.ts`

```typescript
/**
 * Geocoding service using Nominatim (OpenStreetMap)
 * Rate limited to 1 request/second per Nominatim usage policy
 */

interface GeocodingResult {
  latitude: number;
  longitude: number;
  displayName: string;
  confidence: number;
}

export class GeocodingService {
  private readonly baseUrl = 'https://nominatim.openstreetmap.org/search';
  private readonly userAgent = 'Itinerizer/1.0 (travel itinerary app)';
  private lastRequestTime = 0;
  
  /**
   * Geocode a location string
   * @param query - Location to geocode (e.g., "JFK Airport, New York" or "Marriott Times Square")
   */
  async geocode(query: string): Promise<GeocodingResult | null> {
    // Rate limit: 1 request per second
    await this.rateLimit();
    
    const url = new URL(this.baseUrl);
    url.searchParams.set('q', query);
    url.searchParams.set('format', 'json');
    url.searchParams.set('limit', '1');
    
    try {
      const response = await fetch(url.toString(), {
        headers: {
          'User-Agent': this.userAgent,
        },
      });
      
      if (!response.ok) {
        console.warn(`Geocoding failed for "${query}": ${response.status}`);
        return null;
      }
      
      const data = await response.json();
      
      if (data.length === 0) {
        return null;
      }
      
      const result = data[0];
      return {
        latitude: parseFloat(result.lat),
        longitude: parseFloat(result.lon),
        displayName: result.display_name,
        confidence: this.calculateConfidence(result),
      };
    } catch (error) {
      console.error(`Geocoding error for "${query}":`, error);
      return null;
    }
  }
  
  /**
   * Geocode multiple locations with batching
   */
  async geocodeBatch(queries: string[]): Promise<Map<string, GeocodingResult | null>> {
    const results = new Map<string, GeocodingResult | null>();
    
    for (const query of queries) {
      const result = await this.geocode(query);
      results.set(query, result);
    }
    
    return results;
  }
  
  private async rateLimit(): Promise<void> {
    const now = Date.now();
    const elapsed = now - this.lastRequestTime;
    const minInterval = 1000; // 1 second
    
    if (elapsed < minInterval) {
      await new Promise(resolve => setTimeout(resolve, minInterval - elapsed));
    }
    
    this.lastRequestTime = Date.now();
  }
  
  private calculateConfidence(result: any): number {
    // Higher importance = higher confidence
    const importance = parseFloat(result.importance) || 0;
    return Math.min(100, Math.round(importance * 100));
  }
}
```

## Integrate into Import Pipeline

In `src/services/document-import.service.ts`, add geocoding after LLM extraction:

1. After parsing segments, collect all unique locations
2. Geocode each location
3. Add coordinates to the location objects

```typescript
// After LLM extraction, geocode locations
private async geocodeItinerary(itinerary: Itinerary): Promise<Itinerary> {
  const geocodingService = new GeocodingService();
  
  // Collect unique location queries
  const locationQueries = new Set<string>();
  
  for (const segment of itinerary.segments) {
    if (segment.location?.name) {
      locationQueries.add(this.buildGeocodingQuery(segment.location));
    }
    if (segment.startLocation?.name) {
      locationQueries.add(this.buildGeocodingQuery(segment.startLocation));
    }
    if (segment.endLocation?.name) {
      locationQueries.add(this.buildGeocodingQuery(segment.endLocation));
    }
  }
  
  // Geocode all locations
  const results = await geocodingService.geocodeBatch([...locationQueries]);
  
  // Update segments with coordinates
  // ... apply results to segment locations
  
  return itinerary;
}

private buildGeocodingQuery(location: Location): string {
  const parts = [location.name];
  if (location.address?.city) parts.push(location.address.city);
  if (location.address?.country) parts.push(location.address.country);
  return parts.join(', ');
}
```

## Export from index

Add to `src/services/index.ts`:
```typescript
export { GeocodingService } from './geocoding.service.js';
```

## Add tests

Create `tests/services/geocoding.service.test.ts` with basic tests.