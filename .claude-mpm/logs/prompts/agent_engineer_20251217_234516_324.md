---
timestamp: 2025-12-17T23:45:16.324662+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Implement Zod validation schemas", "timestamp": "2025-12-17T23:45:16.324050+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement Zod validation schemas for the itinerizer-ts CLI at /Users/masa/Projects/itinerizer-ts.

The domain types are already defined in `src/domain/types/`. Now create corresponding Zod schemas in `src/domain/schemas/` that:
1. Validate input data at runtime
2. Parse and transform data (strings to Dates, etc.)
3. Provide helpful error messages

## Files to Create:

### 1. src/domain/schemas/common.schema.ts
Schemas for common enums and primitives:
```typescript
import { z } from 'zod';

// Primitive schemas
export const uuidSchema = z.string().uuid();
export const dateSchema = z.coerce.date();  // Accepts string or Date
export const isoDateSchema = z.string().regex(/^\d{4}-\d{2}-\d{2}$/);  // YYYY-MM-DD only
export const timeSchema = z.string().regex(/^\d{2}:\d{2}$/);  // HH:mm

// Branded ID schemas (using .brand())
export const itineraryIdSchema = uuidSchema.brand<'ItineraryId'>();
export const segmentIdSchema = uuidSchema.brand<'SegmentId'>();
export const travelerIdSchema = uuidSchema.brand<'TravelerId'>();

// Enum schemas (use z.enum with values from common.ts)
export const itineraryStatusSchema = z.enum(['DRAFT', 'PLANNED', 'CONFIRMED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']);
export const tripTypeSchema = z.enum(['LEISURE', 'BUSINESS', 'MIXED']);
export const segmentTypeSchema = z.enum(['FLIGHT', 'HOTEL', 'MEETING', 'ACTIVITY', 'TRANSFER', 'CUSTOM']);
export const segmentStatusSchema = z.enum(['TENTATIVE', 'CONFIRMED', 'WAITLISTED', 'CANCELLED', 'COMPLETED']);
export const travelerTypeSchema = z.enum(['ADULT', 'CHILD', 'INFANT', 'SENIOR']);
export const cabinClassSchema = z.enum(['ECONOMY', 'PREMIUM_ECONOMY', 'BUSINESS', 'FIRST']);
export const transferTypeSchema = z.enum(['TAXI', 'SHUTTLE', 'PRIVATE', 'PUBLIC', 'RIDE_SHARE']);
export const boardBasisSchema = z.enum(['ROOM_ONLY', 'BED_BREAKFAST', 'HALF_BOARD', 'FULL_BOARD', 'ALL_INCLUSIVE']);
export const seatPreferenceSchema = z.enum(['AISLE', 'WINDOW', 'MIDDLE']);
```

### 2. src/domain/schemas/location.schema.ts
```typescript
import { z } from 'zod';

export const coordinatesSchema = z.object({
  latitude: z.number().min(-90).max(90),
  longitude: z.number().min(-180).max(180),
});

export const addressSchema = z.object({
  street: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  postalCode: z.string().optional(),
  country: z.string().length(2).toUpperCase(),  // ISO 2-letter
});

export const locationSchema = z.object({
  name: z.string().min(1),
  code: z.string().length(3).toUpperCase().optional(),  // IATA code
  address: addressSchema.optional(),
  coordinates: coordinatesSchema.optional(),
  timezone: z.string().optional(),  // IANA timezone
});

export const companySchema = z.object({
  name: z.string().min(1),
  code: z.string().toUpperCase().optional(),
  website: z.string().url().optional(),
});
```

### 3. src/domain/schemas/money.schema.ts
```typescript
import { z } from 'zod';

export const currencyCodeSchema = z.string().length(3).toUpperCase().regex(/^[A-Z]{3}$/);

export const moneySchema = z.object({
  amount: z.number().int().nonnegative(),  // Store in cents
  currency: currencyCodeSchema,
});

// For input that might come as decimal (e.g., 10.50)
export const moneyInputSchema = z.object({
  amount: z.number().nonnegative().transform(val => Math.round(val * 100)),  // Convert to cents
  currency: currencyCodeSchema,
});
```

### 4. src/domain/schemas/traveler.schema.ts
```typescript
import { z } from 'zod';
import { travelerIdSchema, travelerTypeSchema, seatPreferenceSchema, dateSchema } from './common.schema';

export const loyaltyProgramSchema = z.object({
  carrier: z.string().min(1),
  number: z.string().min(1),
  tier: z.string().optional(),
});

export const travelPreferencesSchema = z.object({
  seatPreference: seatPreferenceSchema.optional(),
  mealPreference: z.string().optional(),
  hotelChainPreference: z.array(z.string()).optional(),
  accessibility: z.array(z.string()).optional(),
});

export const travelerSchema = z.object({
  id: travelerIdSchema,
  type: travelerTypeSchema,
  firstName: z.string().min(1).max(100),
  lastName: z.string().min(1).max(100),
  middleName: z.string().optional(),
  email: z.string().email().optional(),
  phone: z.string().optional(),
  dateOfBirth: dateSchema.optional(),
  passportNumber: z.string().optional(),
  passportExpiry: dateSchema.optional(),
  passportCountry: z.string().length(2).toUpperCase().optional(),
  loyaltyPrograms: z.array(loyaltyProgramSchema).default([]),
  specialRequests: z.array(z.string()).default([]),
  metadata: z.record(z.unknown()).default({}),
});

// For creating new travelers (ID is optional, will be generated)
export const travelerInputSchema = travelerSchema.omit({ id: true }).extend({
  id: travelerIdSchema.optional(),
});
```

### 5. src/domain/schemas/segment.schema.ts (CRITICAL - Discriminated Union)
```typescript
import { z } from 'zod';
import { 
  segmentIdSchema, travelerIdSchema, 
  segmentStatusSchema, cabinClassSchema, transferTypeSchema, boardBasisSchema,
  dateSchema 
} from './common.schema';
import { locationSchema, companySchema } from './location.schema';
import { moneySchema } from './money.schema';

// Base segment schema (shared fields)
const baseSegmentSchema = z.object({
  id: segmentIdSchema,
  status: segmentStatusSchema.default('TENTATIVE'),
  startDatetime: dateSchema,
  endDatetime: dateSchema,
  travelerIds: z.array(travelerIdSchema).min(1, 'At least one traveler required'),
  confirmationNumber: z.string().optional(),
  bookingReference: z.string().optional(),
  provider: companySchema.optional(),
  price: moneySchema.optional(),
  taxes: moneySchema.optional(),
  fees: moneySchema.optional(),
  totalPrice: moneySchema.optional(),
  notes: z.string().optional(),
  metadata: z.record(z.unknown()).default({}),
  dependsOn: z.array(segmentIdSchema).optional(),
}).refine(
  data => data.endDatetime > data.startDatetime,
  { message: 'End datetime must be after start datetime', path: ['endDatetime'] }
);

// Flight segment
export const flightSegmentSchema = baseSegmentSchema.extend({
  type: z.literal('FLIGHT'),
  airline: companySchema,
  flightNumber: z.string().regex(/^[A-Z0-9]{2,3}\d{1,4}$/, 'Invalid flight number format'),
  origin: locationSchema,
  destination: locationSchema,
  departureTerminal: z.string().optional(),
  arrivalTerminal: z.string().optional(),
  aircraft: z.string().optional(),
  cabinClass: cabinClassSchema.optional(),
  bookingClass: z.string().optional(),
  seatAssignments: z.record(z.string()).optional(),
  durationMinutes: z.number().int().positive().optional(),
  baggageAllowance: z.string().optional(),
});

// Hotel segment
export const hotelSegmentSchema = baseSegmentSchema.extend({
  type: z.literal('HOTEL'),
  property: companySchema,
  location: locationSchema,
  checkInDate: dateSchema,
  checkOutDate: dateSchema,
  checkInTime: z.string().regex(/^\d{2}:\d{2}$/).default('15:00'),
  checkOutTime: z.string().regex(/^\d{2}:\d{2}$/).default('11:00'),
  roomType: z.string().optional(),
  roomCount: z.number().int().positive().default(1),
  boardBasis: boardBasisSchema.optional(),
  cancellationPolicy: z.string().optional(),
  amenities: z.array(z.string()).default([]),
}).refine(
  data => data.checkOutDate > data.checkInDate,
  { message: 'Check-out must be after check-in', path: ['checkOutDate'] }
);

// Meeting segment
export const meetingSegmentSchema = baseSegmentSchema.extend({
  type: z.literal('MEETING'),
  title: z.string().min(1),
  location: locationSchema,
  organizer: z.string().optional(),
  attendees: z.array(z.string()).default([]),
  agenda: z.string().optional(),
  meetingUrl: z.string().url().optional(),
  dialIn: z.string().optional(),
});

// Activity segment
export const activitySegmentSchema = baseSegmentSchema.extend({
  type: z.literal('ACTIVITY'),
  name: z.string().min(1),
  description: z.string().optional(),
  location: locationSchema,
  category: z.string().optional(),
  voucherNumber: z.string().optional(),
});

// Transfer segment
export const transferSegmentSchema = baseSegmentSchema.extend({
  type: z.literal('TRANSFER'),
  transferType: transferTypeSchema,
  pickupLocation: locationSchema,
  dropoffLocation: locationSchema,
  vehicleDetails: z.string().optional(),
  driverName: z.string().optional(),
  driverPhone: z.string().optional(),
});

// Custom segment
export const customSegmentSchema = baseSegmentSchema.extend({
  type: z.literal('CUSTOM'),
  title: z.string().min(1),
  description: z.string().optional(),
  location: locationSchema.optional(),
  customData: z.record(z.unknown()).default({}),
});

// DISCRIMINATED UNION - The main segment schema
export const segmentSchema = z.discriminatedUnion('type', [
  flightSegmentSchema,
  hotelSegmentSchema,
  meetingSegmentSchema,
  activitySegmentSchema,
  transferSegmentSchema,
  customSegmentSchema,
]);

// Type exports from schemas
export type SegmentInput = z.input<typeof segmentSchema>;
export type SegmentOutput = z.output<typeof segmentSchema>;
```

### 6. src/domain/schemas/itinerary.schema.ts
```typescript
import { z } from 'zod';
import { 
  itineraryIdSchema, travelerIdSchema, 
  itineraryStatusSchema, tripTypeSchema, dateSchema 
} from './common.schema';
import { locationSchema } from './location.schema';
import { moneySchema, currencyCodeSchema } from './money.schema';
import { travelerSchema, travelPreferencesSchema } from './traveler.schema';
import { segmentSchema } from './segment.schema';

export const itinerarySchema = z.object({
  id: itineraryIdSchema,
  version: z.number().int().positive().default(1),
  createdAt: dateSchema,
  updatedAt: dateSchema,
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  status: itineraryStatusSchema.default('DRAFT'),
  startDate: dateSchema,
  endDate: dateSchema,
  origin: locationSchema.optional(),
  destinations: z.array(locationSchema).default([]),
  travelers: z.array(travelerSchema).min(1, 'At least one traveler required'),
  primaryTravelerId: travelerIdSchema.optional(),
  createdBy: z.string().optional(),
  segments: z.array(segmentSchema).default([]),
  totalPrice: moneySchema.optional(),
  currency: currencyCodeSchema.optional(),
  tripType: tripTypeSchema.optional(),
  costCenter: z.string().optional(),
  projectCode: z.string().optional(),
  preferences: travelPreferencesSchema.optional(),
  tags: z.array(z.string()).default([]),
  metadata: z.record(z.unknown()).default({}),
}).refine(
  data => data.endDate >= data.startDate,
  { message: 'End date must be on or after start date', path: ['endDate'] }
).refine(
  data => !data.primaryTravelerId || data.travelers.some(t => t.id === data.primaryTravelerId),
  { message: 'Primary traveler must be in travelers list', path: ['primaryTravelerId'] }
);

// For creating new itineraries (fewer required fields)
export const itineraryCreateSchema = z.object({
  title: z.string().min(1).max(255),
  description: z.string().optional(),
  startDate: dateSchema,
  endDate: dateSchema,
  tripType: tripTypeSchema.optional(),
  origin: locationSchema.optional(),
  destinations: z.array(locationSchema).default([]),
  tags: z.array(z.string()).default([]),
}).refine(
  data => data.endDate >= data.startDate,
  { message: 'End date must be on or after start date', path: ['endDate'] }
);

// Type exports
export type ItineraryInput = z.input<typeof itinerarySchema>;
export type ItineraryOutput = z.output<typeof itinerarySchema>;
export type ItineraryCreateInput = z.input<typeof itineraryCreateSchema>;
```

### 7. src/domain/schemas/index.ts
Re-export all schemas from a single entry point.

## Requirements:
- All schemas must pass Biome lint
- Run `npm run typecheck` to verify
- Run `npm run build` to verify
- Test that schemas work with sample data

After implementation, verify all tools pass and return the list of files created.