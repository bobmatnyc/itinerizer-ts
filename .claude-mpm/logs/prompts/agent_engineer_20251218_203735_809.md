---
timestamp: 2025-12-18T20:37:35.809715+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Add confidence threshold and Travel Agent review", "timestamp": "2025-12-18T20:37:35.805661+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement two features to improve gap-filling quality:

## 1. Confidence Threshold (80%)

**Current**: Gap-fills are created at 60% confidence
**Required**: Only create gap-fills at 80%+ confidence, skip lower confidence

**In `src/services/segment-continuity.service.ts`**:

Add confidence calculation based on:
- **HIGH confidence (90%+)**: Airport → Hotel/Activity in same city (obvious transfer needed)
- **HIGH confidence (90%+)**: Activity → Airport in same city (obvious transfer needed)
- **MEDIUM confidence (80%)**: Activity → Activity in same city with reasonable time gap
- **LOW confidence (60%)**: Cross-city gaps, overnight gaps, uncertain connections

**Logic**:
```typescript
function calculateGapConfidence(gap: GapInfo, prevSegment: Segment, nextSegment: Segment): number {
  const prevIsAirport = isAirportSegment(prevSegment);
  const nextIsAirport = isAirportSegment(nextSegment);
  const prevIsHotel = prevSegment.type === 'HOTEL';
  const nextIsHotel = nextSegment.type === 'HOTEL';
  
  // Airport transfers are high confidence
  if (prevIsAirport || nextIsAirport) return 95;
  
  // Hotel to activity or activity to hotel
  if ((prevIsHotel && !nextIsHotel) || (!prevIsHotel && nextIsHotel)) return 85;
  
  // Same city activity to activity
  if (gap.gapType === 'LOCAL_TRANSFER') return 80;
  
  // Cross-city or uncertain
  return 60;
}
```

**Only create gap if confidence >= 80%**

## 2. Travel Agent Semantic Review

Add a post-processing step that uses higher-level reasoning to catch obvious errors.

**Create `src/services/travel-agent-review.service.ts`**:

```typescript
interface SemanticIssue {
  type: 'MISSING_AIRPORT_TRANSFER' | 'OVERLAPPING_TIMES' | 'IMPOSSIBLE_SEQUENCE';
  severity: 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;
  suggestedFix?: Segment;
}

class TravelAgentReviewService {
  /**
   * Semantic review of itinerary for obvious issues
   */
  reviewItinerary(itinerary: Itinerary): SemanticIssue[] {
    const issues: SemanticIssue[] = [];
    
    // Rule 1: Flight arrival must have transfer to next non-airport segment
    issues.push(...this.checkFlightArrivals(itinerary.segments));
    
    // Rule 2: Flight departure must have transfer from previous non-airport segment
    issues.push(...this.checkFlightDepartures(itinerary.segments));
    
    // Rule 3: No segment should start before previous one ends
    issues.push(...this.checkTimeOverlaps(itinerary.segments));
    
    return issues;
  }
  
  private checkFlightArrivals(segments: Segment[]): SemanticIssue[] {
    // For each flight, check if next segment is a transfer OR airport
    // If next segment is hotel/activity without transfer, flag it
  }
}
```

**Integrate into import pipeline**:
After gap-filling, run semantic review and auto-fix HIGH severity issues.

**Test with**: The NYC itinerary with the SFO→JFK flight followed by hotel without transfer.