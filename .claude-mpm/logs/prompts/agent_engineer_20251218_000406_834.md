---
timestamp: 2025-12-18T00:04:06.834799+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Implement storage layer", "timestamp": "2025-12-18T00:04:06.834182+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement the storage layer for the itinerizer-ts CLI at /Users/masa/Projects/itinerizer-ts.

## Files to Create:

### 1. src/storage/storage.interface.ts
Define the storage interface:
```typescript
import type { Result } from '../core/result';
import type { StorageError } from '../core/errors';
import type { Itinerary } from '../domain/types/itinerary';
import type { ItineraryId } from '../domain/types/branded';

export interface ItineraryStorage {
  /** Initialize storage (create directories if needed) */
  initialize(): Promise<Result<void, StorageError>>;
  
  /** Save an itinerary (create or update) */
  save(itinerary: Itinerary): Promise<Result<Itinerary, StorageError>>;
  
  /** Load an itinerary by ID */
  load(id: ItineraryId): Promise<Result<Itinerary, StorageError>>;
  
  /** Delete an itinerary */
  delete(id: ItineraryId): Promise<Result<void, StorageError>>;
  
  /** List all itinerary summaries (id, title, status, dates) */
  list(): Promise<Result<ItinerarySummary[], StorageError>>;
  
  /** Check if an itinerary exists */
  exists(id: ItineraryId): Promise<boolean>;
}

export interface ItinerarySummary {
  id: ItineraryId;
  title: string;
  status: string;
  startDate: Date;
  endDate: Date;
  travelerCount: number;
  segmentCount: number;
  updatedAt: Date;
}
```

### 2. src/storage/json-storage.ts
Implement JSON file-based storage:
```typescript
import { readFile, writeFile, unlink, readdir, mkdir, access } from 'node:fs/promises';
import { join } from 'node:path';
import { ok, err } from '../core/result';
import { createStorageError } from '../core/errors';
import type { ItineraryStorage, ItinerarySummary } from './storage.interface';
import type { Itinerary } from '../domain/types/itinerary';
import type { ItineraryId } from '../domain/types/branded';
import { itinerarySchema } from '../domain/schemas/itinerary.schema';

export class JsonItineraryStorage implements ItineraryStorage {
  constructor(private readonly basePath: string = './data/itineraries') {}

  // Helper: Get file path for an itinerary
  private getPath(id: ItineraryId): string {
    return join(this.basePath, `${id}.json`);
  }

  // Helper: Serialize with proper Date handling
  private serialize(itinerary: Itinerary): string {
    return JSON.stringify(itinerary, (key, value) => {
      if (value instanceof Date) {
        return { __type: 'Date', value: value.toISOString() };
      }
      return value;
    }, 2);
  }

  // Helper: Deserialize with Date revival
  private deserialize(json: string): unknown {
    return JSON.parse(json, (key, value) => {
      if (value && typeof value === 'object' && value.__type === 'Date') {
        return new Date(value.value);
      }
      return value;
    });
  }

  async initialize(): Promise<Result<void, StorageError>> {
    // Create directory if it doesn't exist
  }

  async save(itinerary: Itinerary): Promise<Result<Itinerary, StorageError>> {
    // Update version and timestamps
    // Write to file atomically (write to .tmp, then rename)
  }

  async load(id: ItineraryId): Promise<Result<Itinerary, StorageError>> {
    // Read file, deserialize, validate with Zod schema
    // Return NOT_FOUND error if doesn't exist
  }

  async delete(id: ItineraryId): Promise<Result<void, StorageError>> {
    // Delete file, return NOT_FOUND if doesn't exist
  }

  async list(): Promise<Result<ItinerarySummary[], StorageError>> {
    // Read directory, load each file, extract summary
    // Sort by updatedAt descending
  }

  async exists(id: ItineraryId): Promise<boolean> {
    // Check if file exists
  }
}
```

### 3. src/storage/config-storage.ts
Store app configuration (working itinerary, settings):
```typescript
import { readFile, writeFile, mkdir } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { ok, err } from '../core/result';
import type { Result } from '../core/result';
import type { StorageError } from '../core/errors';
import type { ItineraryId } from '../domain/types/branded';

export interface AppConfig {
  workingItineraryId?: ItineraryId;
  defaultCurrency?: string;
  lastUpdated: Date;
}

export class ConfigStorage {
  private config: AppConfig | null = null;

  constructor(private readonly configPath: string = './.itinerizer/config.json') {}

  async load(): Promise<Result<AppConfig, StorageError>>;
  async save(config: AppConfig): Promise<Result<void, StorageError>>;
  
  async getWorkingItineraryId(): Promise<ItineraryId | undefined>;
  async setWorkingItineraryId(id: ItineraryId | undefined): Promise<Result<void, StorageError>>;
  
  async initialize(): Promise<Result<void, StorageError>>;
}
```

### 4. src/storage/index.ts
Re-export everything:
```typescript
export * from './storage.interface';
export { JsonItineraryStorage } from './json-storage';
export { ConfigStorage, type AppConfig } from './config-storage';
```

## Requirements:
- Use Result type for all operations (no throwing)
- Atomic file writes (write to .tmp, then rename)
- Proper Date serialization/deserialization
- Validate loaded data with Zod schemas
- Handle file system errors gracefully
- All files must pass Biome lint and TypeScript check

## Testing:
Create tests in `tests/storage/` to verify:
- Initialize creates directory
- Save/load roundtrip preserves data
- Delete removes file
- List returns sorted summaries
- Config storage works

After implementation, run:
- `npm run lint`
- `npm run typecheck`
- `npm run build`
- `npm test`

Return the list of files created and test results.