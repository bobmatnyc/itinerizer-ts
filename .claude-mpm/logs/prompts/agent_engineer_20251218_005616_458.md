---
timestamp: 2025-12-18T00:56:16.458507+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Implement segment add and move commands", "timestamp": "2025-12-18T00:56:16.457709+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement the segment add and move commands for the itinerizer-ts CLI at /Users/masa/Projects/itinerizer-ts.

These are the remaining critical segment commands needed.

## 1. src/cli/commands/segment/add.ts
Interactive segment addition with full prompts for each segment type:

```typescript
import { Command } from 'commander';
import * as p from '@clack/prompts';
import { JsonItineraryStorage } from '../../../storage/json-storage.js';
import { ConfigStorage } from '../../../storage/config-storage.js';
import { SegmentService } from '../../../services/segment.service.js';
import { WorkingContextService } from '../../../services/working-context.service.js';
import { generateSegmentId } from '../../../domain/types/branded.js';
import type { SegmentType } from '../../../domain/types/common.js';
import { colors, printError, printSuccess } from '../../output/colors.js';
import { formatSegment } from '../../output/formatters.js';
import { handleCancel, promptDate, promptText, promptOptionalText } from '../../prompts/common.prompts.js';
import { promptSegmentType, promptSegmentStatus } from '../../prompts/segment.prompts.js';

export function addCommand(): Command {
  return new Command('add')
    .description('Add a segment to the working itinerary')
    .option('-t, --type <type>', 'Segment type (FLIGHT, HOTEL, MEETING, ACTIVITY, TRANSFER, CUSTOM)')
    .action(async (options) => {
      p.intro(colors.heading('Add Segment'));
      
      // Get working itinerary
      const storage = new JsonItineraryStorage();
      const configStorage = new ConfigStorage();
      await configStorage.initialize();
      const segmentService = new SegmentService(storage);
      const workingService = new WorkingContextService(configStorage, storage);
      
      const workingResult = await workingService.getWorkingItinerary();
      if (!workingResult.success || !workingResult.value) {
        printError('No working itinerary set. Use "itinerizer itinerary use <id>" first.');
        process.exit(1);
      }
      
      const itinerary = workingResult.value;
      
      // Get segment type
      let segmentType: SegmentType;
      if (options.type) {
        segmentType = options.type.toUpperCase() as SegmentType;
      } else {
        segmentType = await promptSegmentType();
      }
      
      // Get base segment info
      const status = await promptSegmentStatus();
      
      const startDatetime = await promptDate('Start date/time (YYYY-MM-DD HH:mm):');
      const endDatetime = await promptDate('End date/time (YYYY-MM-DD HH:mm):');
      
      if (endDatetime <= startDatetime) {
        printError('End time must be after start time');
        process.exit(1);
      }
      
      // Get traveler IDs (default to all travelers if not specified)
      const travelerIds = itinerary.travelers.map(t => t.id);
      
      const notes = await promptOptionalText('Notes (optional):');
      
      // Type-specific prompts
      let typeSpecificData: Record<string, unknown> = {};
      
      switch (segmentType) {
        case 'FLIGHT': {
          const airline = await promptText('Airline name:');
          const airlineCode = await promptOptionalText('Airline code (e.g., UA):');
          const flightNumber = await promptText('Flight number (e.g., UA123):');
          const originCode = await promptText('Origin airport code (e.g., SFO):');
          const originName = await promptOptionalText('Origin airport name:');
          const destCode = await promptText('Destination airport code (e.g., JFK):');
          const destName = await promptOptionalText('Destination airport name:');
          const cabinClass = await p.select({
            message: 'Cabin class:',
            options: [
              { value: 'ECONOMY', label: 'Economy' },
              { value: 'PREMIUM_ECONOMY', label: 'Premium Economy' },
              { value: 'BUSINESS', label: 'Business' },
              { value: 'FIRST', label: 'First' },
            ],
          });
          handleCancel(cabinClass);
          
          typeSpecificData = {
            airline: { name: airline, ...(airlineCode ? { code: airlineCode.toUpperCase() } : {}) },
            flightNumber: flightNumber.toUpperCase(),
            origin: { name: originName || originCode.toUpperCase(), code: originCode.toUpperCase() },
            destination: { name: destName || destCode.toUpperCase(), code: destCode.toUpperCase() },
            cabinClass,
          };
          break;
        }
        
        case 'HOTEL': {
          const propertyName = await promptText('Hotel name:');
          const locationName = await promptText('Location:');
          const locationCode = await promptOptionalText('City code (e.g., NYC):');
          const roomType = await promptOptionalText('Room type:');
          const checkInDate = new Date(startDatetime.toISOString().split('T')[0]);
          const checkOutDate = new Date(endDatetime.toISOString().split('T')[0]);
          
          typeSpecificData = {
            property: { name: propertyName },
            location: { name: locationName, ...(locationCode ? { code: locationCode.toUpperCase() } : {}) },
            checkInDate,
            checkOutDate,
            roomType,
            roomCount: 1,
            amenities: [],
          };
          break;
        }
        
        case 'MEETING': {
          const title = await promptText('Meeting title:');
          const locationName = await promptText('Location:');
          const organizer = await promptOptionalText('Organizer:');
          const agenda = await promptOptionalText('Agenda:');
          const meetingUrl = await promptOptionalText('Meeting URL (for virtual):');
          
          typeSpecificData = {
            title,
            location: { name: locationName },
            organizer,
            attendees: [],
            agenda,
            meetingUrl,
          };
          break;
        }
        
        case 'ACTIVITY': {
          const name = await promptText('Activity name:');
          const description = await promptOptionalText('Description:');
          const locationName = await promptText('Location:');
          const category = await promptOptionalText('Category:');
          
          typeSpecificData = {
            name,
            description,
            location: { name: locationName },
            category,
          };
          break;
        }
        
        case 'TRANSFER': {
          const transferType = await p.select({
            message: 'Transfer type:',
            options: [
              { value: 'TAXI', label: 'Taxi' },
              { value: 'SHUTTLE', label: 'Shuttle' },
              { value: 'PRIVATE', label: 'Private Car' },
              { value: 'PUBLIC', label: 'Public Transport' },
              { value: 'RIDE_SHARE', label: 'Ride Share' },
            ],
          });
          handleCancel(transferType);
          
          const pickupName = await promptText('Pickup location:');
          const dropoffName = await promptText('Dropoff location:');
          
          typeSpecificData = {
            transferType,
            pickupLocation: { name: pickupName },
            dropoffLocation: { name: dropoffName },
          };
          break;
        }
        
        case 'CUSTOM': {
          const title = await promptText('Title:');
          const description = await promptOptionalText('Description:');
          const locationName = await promptOptionalText('Location:');
          
          typeSpecificData = {
            title,
            description,
            ...(locationName ? { location: { name: locationName } } : {}),
            customData: {},
          };
          break;
        }
      }
      
      // Create segment
      const spinner = p.spinner();
      spinner.start('Adding segment...');
      
      const segment = {
        id: generateSegmentId(),
        type: segmentType,
        status: status as 'TENTATIVE' | 'CONFIRMED' | 'WAITLISTED' | 'CANCELLED' | 'COMPLETED',
        startDatetime,
        endDatetime,
        travelerIds,
        ...(notes ? { notes } : {}),
        metadata: {},
        ...typeSpecificData,
      };
      
      const result = await segmentService.add(itinerary.id, segment as any);
      
      if (!result.success) {
        spinner.stop('Failed to add segment');
        printError(result.error.message);
        process.exit(1);
      }
      
      spinner.stop('Segment added!');
      
      // Find the added segment
      const addedSegment = result.value.segments.find(s => s.id === segment.id);
      if (addedSegment) {
        console.log('\n' + formatSegment(addedSegment, result.value.segments.length));
      }
      
      p.outro(`Added to: ${itinerary.title}`);
    });
}
```

## 2. src/cli/commands/segment/move.ts
Move a segment with dependency cascade preview:

```typescript
import { Command } from 'commander';
import * as p from '@clack/prompts';
import { JsonItineraryStorage } from '../../../storage/json-storage.js';
import { ConfigStorage } from '../../../storage/config-storage.js';
import { SegmentService } from '../../../services/segment.service.js';
import { DependencyService } from '../../../services/dependency.service.js';
import { WorkingContextService } from '../../../services/working-context.service.js';
import { createSegmentId } from '../../../domain/types/branded.js';
import { colors, printError, printSuccess, printWarning } from '../../output/colors.js';
import { formatSegment, formatDateRange } from '../../output/formatters.js';
import { handleCancel, promptConfirm } from '../../prompts/common.prompts.js';
import { promptSelectSegment } from '../../prompts/segment.prompts.js';

export function moveCommand(): Command {
  return new Command('move')
    .description('Move a segment (adjusts dependent segments)')
    .argument('[segment-id]', 'Segment ID to move')
    .option('--by <minutes>', 'Time shift in minutes (positive=later, negative=earlier)')
    .option('--to <datetime>', 'New start datetime (YYYY-MM-DD HH:mm)')
    .option('--preview', 'Preview changes without applying', false)
    .action(async (segmentIdArg, options) => {
      p.intro(colors.heading('Move Segment'));
      
      // Get working itinerary
      const storage = new JsonItineraryStorage();
      const configStorage = new ConfigStorage();
      await configStorage.initialize();
      const segmentService = new SegmentService(storage);
      const dependencyService = new DependencyService();
      const workingService = new WorkingContextService(configStorage, storage);
      
      const workingResult = await workingService.getWorkingItinerary();
      if (!workingResult.success || !workingResult.value) {
        printError('No working itinerary set. Use "itinerizer itinerary use <id>" first.');
        process.exit(1);
      }
      
      const itinerary = workingResult.value;
      
      if (itinerary.segments.length === 0) {
        p.note('No segments in this itinerary');
        return;
      }
      
      // Get segment to move
      let segmentId;
      if (segmentIdArg) {
        // Find by partial match
        const match = itinerary.segments.find(s => s.id.startsWith(segmentIdArg));
        segmentId = match ? match.id : createSegmentId(segmentIdArg);
      } else {
        segmentId = await promptSelectSegment(itinerary.segments, 'Select segment to move:');
      }
      
      const segment = itinerary.segments.find(s => s.id === segmentId);
      if (!segment) {
        printError(`Segment not found: ${segmentId}`);
        process.exit(1);
      }
      
      console.log('\nCurrent segment:');
      console.log(formatSegment(segment, 1));
      
      // Calculate time delta
      let timeDeltaMs: number;
      
      if (options.by) {
        timeDeltaMs = parseInt(options.by, 10) * 60 * 1000;
      } else if (options.to) {
        const newStart = new Date(options.to);
        if (isNaN(newStart.getTime())) {
          printError('Invalid datetime format. Use YYYY-MM-DD HH:mm');
          process.exit(1);
        }
        timeDeltaMs = newStart.getTime() - segment.startDatetime.getTime();
      } else {
        // Interactive: ask for shift
        const shiftType = await p.select({
          message: 'How would you like to move it?',
          options: [
            { value: 'later', label: 'Later (delay)' },
            { value: 'earlier', label: 'Earlier (advance)' },
            { value: 'specific', label: 'To specific time' },
          ],
        });
        handleCancel(shiftType);
        
        if (shiftType === 'specific') {
          const newStartStr = await p.text({
            message: 'New start time (YYYY-MM-DD HH:mm):',
            placeholder: segment.startDatetime.toISOString().slice(0, 16).replace('T', ' '),
          });
          handleCancel(newStartStr);
          const newStart = new Date(newStartStr as string);
          timeDeltaMs = newStart.getTime() - segment.startDatetime.getTime();
        } else {
          const minutesStr = await p.text({
            message: 'By how many minutes?',
            placeholder: '60',
            validate: (v) => {
              const n = parseInt(v, 10);
              return isNaN(n) || n <= 0 ? 'Enter a positive number' : undefined;
            },
          });
          handleCancel(minutesStr);
          const minutes = parseInt(minutesStr as string, 10);
          timeDeltaMs = shiftType === 'earlier' ? -minutes * 60 * 1000 : minutes * 60 * 1000;
        }
      }
      
      // Calculate affected segments
      const adjustResult = dependencyService.adjustDependentSegments(
        itinerary.segments,
        segmentId,
        timeDeltaMs
      );
      
      if (!adjustResult.success) {
        printError(adjustResult.error.message);
        process.exit(1);
      }
      
      // Find which segments changed
      const changedSegments = adjustResult.value.filter((newSeg, i) => {
        const oldSeg = itinerary.segments.find(s => s.id === newSeg.id);
        return oldSeg && oldSeg.startDatetime.getTime() !== newSeg.startDatetime.getTime();
      });
      
      // Show preview
      if (changedSegments.length > 0) {
        console.log(colors.heading('\nAffected segments:'));
        for (const seg of changedSegments) {
          const oldSeg = itinerary.segments.find(s => s.id === seg.id)!;
          const shiftMin = Math.round((seg.startDatetime.getTime() - oldSeg.startDatetime.getTime()) / 60000);
          const shiftDir = shiftMin > 0 ? 'later' : 'earlier';
          console.log(`  ${colors.info('→')} ${seg.type === 'FLIGHT' ? (seg as any).flightNumber : 
                        seg.type === 'HOTEL' ? (seg as any).property?.name :
                        seg.type === 'MEETING' ? (seg as any).title :
                        seg.type === 'ACTIVITY' ? (seg as any).name :
                        seg.type === 'TRANSFER' ? 'Transfer' :
                        (seg as any).title}`);
          console.log(`    ${colors.dim(formatDateRange(oldSeg.startDatetime, oldSeg.endDatetime))} → ${formatDateRange(seg.startDatetime, seg.endDatetime)}`);
          console.log(`    ${colors.dim(`(${Math.abs(shiftMin)} min ${shiftDir})`)}`);
        }
      } else {
        p.note('No dependent segments will be affected');
      }
      
      // Validate no conflicts
      const conflictResult = dependencyService.validateNoConflicts(adjustResult.value);
      if (!conflictResult.success) {
        printWarning(`Warning: ${conflictResult.error.message}`);
      }
      
      if (options.preview) {
        p.outro('Preview complete (no changes applied)');
        return;
      }
      
      // Confirm
      const proceed = await promptConfirm(`Apply changes to ${changedSegments.length} segment(s)?`);
      if (!proceed) {
        p.cancel('Move cancelled');
        return;
      }
      
      // Apply changes
      const spinner = p.spinner();
      spinner.start('Moving segments...');
      
      // Save the adjusted itinerary
      const updatedItinerary = {
        ...itinerary,
        segments: adjustResult.value,
        updatedAt: new Date(),
      };
      
      const saveResult = await storage.save(updatedItinerary);
      
      if (!saveResult.success) {
        spinner.stop('Failed to save changes');
        printError(saveResult.error.message);
        process.exit(1);
      }
      
      spinner.stop('Segments moved!');
      printSuccess(`Moved ${changedSegments.length} segment(s)`);
      
      p.outro('Done');
    });
}
```

## 3. Update src/cli/commands/segment.command.ts

Add the new commands to the segment command router:

```typescript
import { Command } from 'commander';
import { listCommand } from './segment/list.js';
import { deleteCommand } from './segment/delete.js';
import { addCommand } from './segment/add.js';
import { moveCommand } from './segment/move.js';

export function segmentCommand(): Command {
  const cmd = new Command('segment')
    .alias('seg')
    .description('Manage itinerary segments');

  cmd.addCommand(addCommand());
  cmd.addCommand(listCommand());
  cmd.addCommand(moveCommand());
  cmd.addCommand(deleteCommand());

  return cmd;
}
```

## Requirements:
- Interactive prompts for all segment types
- Type-specific fields (flight number, hotel name, etc.)
- Dependency cascade preview before applying
- Preview-only mode with --preview flag
- Partial ID matching

After implementation:
- Run `npm run lint`
- Run `npm run typecheck`
- Run `npm run build`

Return list of files created/modified.