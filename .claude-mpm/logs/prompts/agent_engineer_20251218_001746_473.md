---
timestamp: 2025-12-18T00:17:46.473080+00:00
type: agent_engineer
metadata: {"agent_type": "engineer", "agent_id": "engineer_bc691194-b92e-4217-8fbe-378faa708438", "session_id": "bc691194-b92e-4217-8fbe-378faa708438", "delegation_context": {"description": "Implement services layer", "timestamp": "2025-12-18T00:17:46.471924+00:00"}}
---


AGENT MEMORY - PROJECT-SPECIFIC KNOWLEDGE:
# Agent Memory: engineer
<!-- Last Updated: 2025-12-17T23:24:44.617242+00:00Z -->



INSTRUCTIONS: Review your memory above before proceeding. Apply learned patterns and avoid known mistakes.


Implement the services layer for the itinerizer-ts CLI at /Users/masa/Projects/itinerizer-ts.

## Files to Create:

### 1. src/services/itinerary.service.ts
High-level itinerary operations:
```typescript
import type { Result } from '../core/result';
import type { StorageError, ValidationError } from '../core/errors';
import type { Itinerary } from '../domain/types/itinerary';
import type { ItineraryId } from '../domain/types/branded';
import type { Traveler } from '../domain/types/traveler';
import type { ItineraryStorage, ItinerarySummary } from '../storage/storage.interface';
import { itineraryCreateSchema } from '../domain/schemas/itinerary.schema';

export class ItineraryService {
  constructor(private readonly storage: ItineraryStorage) {}

  /** Create a new itinerary from input */
  async create(input: {
    title: string;
    startDate: Date;
    endDate: Date;
    description?: string;
    tripType?: 'LEISURE' | 'BUSINESS' | 'MIXED';
    travelers?: Traveler[];
  }): Promise<Result<Itinerary, ValidationError | StorageError>>;

  /** Get an itinerary by ID */
  async get(id: ItineraryId): Promise<Result<Itinerary, StorageError>>;

  /** Update an itinerary (partial update) */
  async update(
    id: ItineraryId, 
    updates: Partial<Pick<Itinerary, 'title' | 'description' | 'status' | 'startDate' | 'endDate' | 'tripType' | 'tags'>>
  ): Promise<Result<Itinerary, StorageError | ValidationError>>;

  /** Delete an itinerary */
  async delete(id: ItineraryId): Promise<Result<void, StorageError>>;

  /** List all itineraries (summaries) */
  async list(): Promise<Result<ItinerarySummary[], StorageError>>;

  /** Add a traveler to an itinerary */
  async addTraveler(id: ItineraryId, traveler: Traveler): Promise<Result<Itinerary, StorageError>>;

  /** Remove a traveler from an itinerary */
  async removeTraveler(id: ItineraryId, travelerId: TravelerId): Promise<Result<Itinerary, StorageError>>;
}
```

### 2. src/services/segment.service.ts
Segment CRUD operations:
```typescript
import type { Result } from '../core/result';
import type { StorageError, ValidationError } from '../core/errors';
import type { Itinerary } from '../domain/types/itinerary';
import type { Segment } from '../domain/types/segment';
import type { ItineraryId, SegmentId } from '../domain/types/branded';
import type { ItineraryStorage } from '../storage/storage.interface';

export class SegmentService {
  constructor(private readonly storage: ItineraryStorage) {}

  /** Add a segment to an itinerary */
  async add(
    itineraryId: ItineraryId, 
    segment: Omit<Segment, 'id'> & { id?: SegmentId }
  ): Promise<Result<Itinerary, StorageError | ValidationError>>;

  /** Update a segment */
  async update(
    itineraryId: ItineraryId,
    segmentId: SegmentId,
    updates: Partial<Segment>
  ): Promise<Result<Itinerary, StorageError | ValidationError>>;

  /** Delete a segment */
  async delete(
    itineraryId: ItineraryId,
    segmentId: SegmentId
  ): Promise<Result<Itinerary, StorageError>>;

  /** Get a specific segment */
  async get(
    itineraryId: ItineraryId,
    segmentId: SegmentId
  ): Promise<Result<Segment, StorageError>>;

  /** Reorder segments (update sort order) */
  async reorder(
    itineraryId: ItineraryId,
    segmentIds: SegmentId[]
  ): Promise<Result<Itinerary, StorageError>>;
}
```

### 3. src/services/dependency.service.ts (CRITICAL)
Segment dependency tracking and cascade adjustments:
```typescript
import type { Result } from '../core/result';
import type { DependencyError } from '../core/errors';
import type { Segment } from '../domain/types/segment';
import type { SegmentId } from '../domain/types/branded';

export interface DependencyGraph {
  nodes: Map<SegmentId, Segment>;
  edges: Map<SegmentId, SegmentId[]>;  // segment -> segments that depend on it
}

export class DependencyService {
  /** Build a dependency graph from segments */
  buildGraph(segments: Segment[]): DependencyGraph;

  /** Check for circular dependencies */
  validateNoCycles(segments: Segment[]): Result<void, DependencyError>;

  /** Get topological order (dependencies first) */
  getTopologicalOrder(segments: Segment[]): Result<Segment[], DependencyError>;

  /** Find all segments that depend on a given segment (directly or transitively) */
  findDependents(segments: Segment[], segmentId: SegmentId): SegmentId[];

  /** 
   * Adjust dependent segments when a segment is moved.
   * Uses HYBRID approach:
   * 1. Explicit dependencies from dependsOn field
   * 2. Chronological auto-detection for overlapping segments
   * 
   * @param segments All segments in the itinerary
   * @param movedSegmentId The segment that was moved
   * @param timeDelta The time shift in milliseconds (positive = later, negative = earlier)
   * @returns Updated segments with cascaded time adjustments
   */
  adjustDependentSegments(
    segments: Segment[],
    movedSegmentId: SegmentId,
    timeDelta: number
  ): Result<Segment[], DependencyError>;

  /**
   * Infer chronological dependencies.
   * A segment B depends on segment A if:
   * - B starts within 30 minutes after A ends
   * - B is not a "background" segment (hotels can run in parallel)
   */
  inferChronologicalDependencies(segments: Segment[]): Map<SegmentId, SegmentId[]>;

  /**
   * Check if two segments would overlap (considering exclusive segment types).
   * Hotels and meetings can overlap, but flights and transfers cannot.
   */
  wouldOverlap(a: Segment, b: Segment): boolean;

  /**
   * Validate no exclusive segments overlap after adjustment.
   */
  validateNoConflicts(segments: Segment[]): Result<void, DependencyError>;
}
```

### 4. src/services/working-context.service.ts
Track current working itinerary:
```typescript
import type { Result } from '../core/result';
import type { StorageError } from '../core/errors';
import type { Itinerary } from '../domain/types/itinerary';
import type { ItineraryId } from '../domain/types/branded';
import type { ConfigStorage } from '../storage/config-storage';
import type { ItineraryStorage } from '../storage/storage.interface';

export class WorkingContextService {
  constructor(
    private readonly configStorage: ConfigStorage,
    private readonly itineraryStorage: ItineraryStorage
  ) {}

  /** Get the current working itinerary */
  async getWorkingItinerary(): Promise<Result<Itinerary | null, StorageError>>;

  /** Set the working itinerary by ID */
  async setWorkingItinerary(id: ItineraryId): Promise<Result<Itinerary, StorageError>>;

  /** Clear the working itinerary */
  async clearWorkingItinerary(): Promise<Result<void, StorageError>>;

  /** Get just the working itinerary ID (without loading the full itinerary) */
  async getWorkingItineraryId(): Promise<ItineraryId | undefined>;

  /** Check if there's a working itinerary set */
  async hasWorkingItinerary(): Promise<boolean>;
}
```

### 5. src/services/index.ts
Re-export all services:
```typescript
export { ItineraryService } from './itinerary.service';
export { SegmentService } from './segment.service';
export { DependencyService } from './dependency.service';
export { WorkingContextService } from './working-context.service';
```

## Key Implementation Details:

### Dependency Service Algorithm:
1. **Build Graph**: Create adjacency list from explicit `dependsOn` fields
2. **Infer Chronological**: Add edges for segments that start soon after another ends
3. **Detect Cycles**: Use DFS with recursion stack
4. **Topological Sort**: Kahn's algorithm or DFS-based
5. **Cascade Adjustment**: BFS from moved segment, apply time delta

### Segment Type Rules:
- **Exclusive (cannot overlap)**: FLIGHT, TRANSFER
- **Background (can run in parallel)**: HOTEL
- **Flexible (can overlap each other)**: MEETING, ACTIVITY, CUSTOM

### Time Inference:
- If segment B starts within 30 minutes of segment A ending, infer B depends on A
- Exception: Hotels are background, don't create dependencies

## Tests:
Create tests in `tests/services/`:
1. `itinerary.service.test.ts` - CRUD operations
2. `segment.service.test.ts` - Segment CRUD
3. `dependency.service.test.ts` - Dependency graph, cycle detection, cascade
4. `working-context.service.test.ts` - Working itinerary management

## Requirements:
- All methods return Result types
- Use dependency injection (services receive storage in constructor)
- All files pass Biome lint and TypeScript check
- Comprehensive tests for dependency logic

Return the list of files created and test results.